import sys
import os

import pandas as pd

sys.path.insert(0, os.getcwd())

from modules.dataPreprocessing.transformer import DataTransformer
from modules.dataPreprocessing.outlier_analysis.KNN import KNNAnalysis
from modules.dataPreprocessing.outlier_analysis.AVF import AVFAnalysis
from modules.logging import logger
from modules.config.pipeline_config import PipelineConfig
from modules.config.utils.config_enums import OutlierRemovalMethod


class OutlierProcessor:
    def __init__(self, pipeline_report: dict) -> None:
        """
        Outlier Analysis & Removal

        Parameters
        ----------
        pipeline_report : dict
            Pipeline report containing train/test split.
        """
        self._pipeline_report = pipeline_report
        self._train_x = pipeline_report["train_x"]  # type: pd.DataFrame
        self._train_y = pipeline_report["train_y"]  # type: pd.Series
        self._test_x = pipeline_report["test_x"]  # type: pd.DataFrame
        self._test_y = pipeline_report["test_y"]  # type: pd.Series
        self._train_df = self._train_x.copy(deep=True).join(
            self._train_y.copy(deep=True)
        )
        self._test_df = self._test_x.copy(deep=True).join(self._test_y.copy(deep=True))

    def avf(self, k: int) -> list[int]:
        """
        Generates indices of outliers using frequency of attribute values without modifying train_x.

        Parameters
        ----------
        k : int
            Number of outliers to generate.

        Returns
        -------
        list[int]
            Indices of outliers in train_x.
        """
        return AVFAnalysis(self._train_df).getOutliers(k)

    def odin(self, k: int, T: int) -> list[int]:
        """
        Generates indexes of outliers using k-nearest-neighbors without modifying train_x.

        Parameters
        ----------
        k : int
            Number of neighbors.

        T : int
            Indegree threshold.

        Returns
        -------
        list[int]
            Indices of outliers in train_x.
        """
        dt = DataTransformer(
            train_x=self._train_df, test_x=self._test_df, train_y=None, test_y=None
        )
        dt.minMaxNormalization("Dag")
        return KNNAnalysis(dt._train_x).getOutliers(k, T)

    def removeOutliers(self, outliers: list[int]) -> None:
        """
        Remove outliers based on their index.

        Parameters
        ----------
        outliers : list[int]
            Indices of outliers. Can be generated by calling methods `odin` or `avf`.
        """
        current_len = len(self._train_x)
        # The DataFrame is indexed in this way, as the index used by the `drop`-method can differ from the one used by `iloc`
        train_idx = self._train_x.iloc[outliers].index
        self._train_x.drop(train_idx, inplace=True)
        self._train_y.drop(train_idx, inplace=True)
        amount = current_len - len(self._train_x)
        logger.info(
            f"Removed {amount} {"outliers" if amount != 1 else "outlier"} from training features"
        )

    def run(self) -> dict:
        """
        Run outlier analysis as specified in the config.

        Returns
        -------
        dict
            Pipeline report containing train features and target labels with potential outliers removed.
        """
        config = PipelineConfig()
        if config.getValue("UseOutlierRemoval"):

            outlier_method = config.getValue("OutlierRemovalMethod")  # type: str
            outliers = None
            match outlier_method:
                case OutlierRemovalMethod.ODIN.name:
                    outliers = self.odin(**config.getValue("odinParams"))
                case OutlierRemovalMethod.AVF.name:
                    outliers = self.avf(**config.getValue("avfParams"))
                case _:
                    logger.warning(
                        "Undefined outlier removal method selected. Skipping"
                    )
            if outliers:
                logger.info(
                    f"Using outlier detection method: '{outlier_method.lower()}'"
                )
                self.removeOutliers(outliers)
        else:
            logger.info("Skipping outlier analysis")

        self._pipeline_report |= {
            "train_x": self._train_x,
            "train_y": self._train_y,
            "test_x": self._test_x,
            "test_y": self._test_y,
        }
        return self._pipeline_report
